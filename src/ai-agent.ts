/**
 * AIAgent - Cloudflare Agent for AI Canvas Operations
 *
 * This Agent handles AI command requests and integrates with RoomDO
 * for atomic Yjs updates. Each room gets its own Agent instance mapped
 * to the room ID.
 *
 * Architecture:
 * - Agent extends Cloudflare's Agent base class
 * - Maintains AI conversation state and idempotency cache
 * - Routes tool executions to RoomDO via RPC
 * - Uses AI Gateway for observability, caching, and cost tracking
 * - Built-in state management via Agent framework
 */

import { verifyToken } from "@clerk/backend";
import { Agent } from "agents";
import type { ToolCall } from "./ai-tools";
import { AI_TOOLS } from "./ai-tools";

// Import Env type from generated worker configuration
/// <reference path="../worker-configuration.d.ts" />

/**
 * AIAgent - Handles AI commands for canvas manipulation
 *
 * Each room gets its own Agent instance (mapped by room ID).
 * Agent maintains:
 * - Recent operations cache for idempotency
 * - Conversation context
 * - Command execution history
 *
 * Note: Agent base class doesn't expose generic type parameter for env.
 * We use type assertion (this.env as Env) to access typed environment bindings.
 * The Env interface is defined in worker-configuration.d.ts (generated by wrangler types).
 */
export class AIAgent extends Agent {
  /**
   * Handle HTTP requests for AI commands
   * Route: POST /ai-command
   *
   * This replaces the Worker route handler and provides
   * built-in state management for idempotency and context.
   */
  async onRequest(request: Request): Promise<Response> {
    // Only handle POST requests for AI commands
    if (request.method !== "POST") {
      return new Response("Method not allowed", { status: 405 });
    }

    // Verify authentication - only editors can send AI commands
    const role = await this.authorizeRequest(request);
    if (role !== "editor") {
      return Response.json(
        {
          success: false,
          error: "Unauthorized. Sign in to use AI commands.",
        },
        { status: 401 },
      );
    }

    // Parse and validate request body
    let body: {
      prompt?: string;
      userName?: string;
      context?: {
        selectedShapeIds?: string[];
        viewportCenter?: { x: number; y: number };
      };
    };

    try {
      body = await request.json();
    } catch {
      return Response.json(
        { success: false, error: "Invalid JSON body" },
        { status: 400 },
      );
    }

    // Validate prompt
    const prompt = body.prompt?.trim();
    if (!prompt) {
      return Response.json(
        { success: false, error: "Prompt is required" },
        { status: 400 },
      );
    }

    // Sanitize and validate prompt length
    const MAX_PROMPT_LENGTH = 1000;
    if (prompt.length > MAX_PROMPT_LENGTH) {
      return Response.json(
        {
          success: false,
          error: `Prompt too long. Maximum ${MAX_PROMPT_LENGTH} characters.`,
        },
        { status: 400 },
      );
    }

    // Generate unique command ID
    const commandId = crypto.randomUUID();

    // Get user info - prefer userName from request body (set by frontend with full user data)
    // Fall back to JWT extraction if not provided
    const { userId, userName: jwtUserName } = await this.getUserInfo(request);
    const userName = body.userName || jwtUserName;

    try {
      // Check idempotency in Agent state
      const cachedResult = await this.getCachedCommand(commandId);
      if (cachedResult) {
        return Response.json(cachedResult);
      }

      // Call AI via Gateway to generate tool calls
      const toolCalls = await this.generateToolCallsWithAI(
        prompt,
        body.context ?? {},
      );

      if (toolCalls.length === 0) {
        return Response.json(
          {
            success: false,
            error:
              "Could not understand command. Try something like 'create a red rectangle at 100, 200'",
          },
          { status: 400 },
        );
      }

      // Validate tool calls before execution
      const validation = this.validateToolCalls(toolCalls);
      if (!validation.valid) {
        console.warn("[AIAgent] Validation failed:", validation.errors);
        return Response.json(
          {
            success: false,
            error: validation.errors.join("; "),
            message: "AI generated invalid commands",
          },
          { status: 400 },
        );
      }

      // Get RoomDO stub and execute via RPC
      const roomId = this.getRoomId(request);

      // Type assertion: Agent base class doesn't provide typed env
      // Env interface defined in worker-configuration.d.ts has all bindings
      // biome-ignore lint/suspicious/noExplicitAny: Agent framework limitation - env property not typed
      const env = this.env as any;

      if (!env.RoomDO) {
        console.error("[AIAgent] ✗ RoomDO binding not found in env");
        throw new Error("RoomDO binding not available");
      }

      const roomStub = env.RoomDO.get(env.RoomDO.idFromName(roomId));

      const result = await roomStub.executeAICommand({
        commandId,
        toolCalls,
        userId,
        userName,
        prompt,
      });

      // Cache result in Agent state
      await this.cacheCommandResult(commandId, result);

      return Response.json(result, {
        status: result.success ? 200 : 500,
      });
    } catch (error) {
      console.error("[AIAgent] ✗ Error in onRequest:", error);
      console.error(
        "[AIAgent] Error stack:",
        error instanceof Error ? error.stack : "No stack",
      );
      return Response.json(
        {
          success: false,
          error: "Failed to execute AI command",
          message: error instanceof Error ? error.message : "Unknown error",
        },
        { status: 500 },
      );
    }
  }

  /**
   * Generate tool calls using Workers AI via AI Gateway
   *
   * This method routes AI requests through AI Gateway for:
   * - Observability (request logs, latency tracking)
   * - Caching (common prompts cached at gateway)
   * - Cost tracking (monitor AI usage)
   * - Failover (gateway handles retries)
   */
  private async generateToolCallsWithAI(
    prompt: string,
    context: {
      selectedShapeIds?: string[];
      viewportCenter?: { x: number; y: number };
    },
  ): Promise<ToolCall[]> {
    const centerX = context.viewportCenter?.x ?? 1000;
    const centerY = context.viewportCenter?.y ?? 1000;

    // Build concise system prompt to avoid token limits
    // Keep it short to prevent response truncation
    let systemPrompt = `Canvas: 2000x2000px. Viewport center: ${centerX},${centerY}.

Available shapes: rectangle (width,height), circle (radius), text (text,fontSize).
Colors: hex format (#FF0000=red, #0000FF=blue, #00FF00=green, #FFFF00=yellow, #800080=purple).
Sizes: small=80, normal=150, large=250.

CRITICAL: Return proper JSON arrays in shapes parameter.
Example: {shapes:[{type:"circle",x:100,y:200,radius:50,fill:"#FF0000"}]}`;

    if (context.selectedShapeIds && context.selectedShapeIds.length > 0) {
      systemPrompt += `\nSelected shapes: ${context.selectedShapeIds.slice(0, 3).join(",")}`;
    }

    try {

      // Check total prompt length to avoid truncation
      const totalPromptLength = systemPrompt.length + prompt.length;
      const MAX_SAFE_PROMPT_LENGTH = 1500; // Leave room for response

      if (totalPromptLength > MAX_SAFE_PROMPT_LENGTH) {
        console.warn(
          `[AIAgent] Prompt too long (${totalPromptLength} chars), truncating context`,
        );
        // Reduce system prompt to essentials
        systemPrompt = `Canvas 2000x2000px. Center: ${centerX},${centerY}. Shapes: rectangle, circle, text. Colors: hex format.`;
      }

      // biome-ignore lint/suspicious/noExplicitAny: Agent framework limitation - env property not typed
      const env = this.env as any;
      const ai = env.AI;

      // Call Workers AI through AI Gateway
      // Use llama-3.1-8b-instruct with proper message format
      const response = await ai.run(
        "@cf/meta/llama-3.1-8b-instruct",
        {
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: prompt },
          ],
          tools: AI_TOOLS,
          // Add max tokens to prevent truncation
          max_tokens: 2048,
        },
        {
          gateway: {
            id: "aw-cf-ai",
          },
        },
      );

      // Extract tool calls from response
      if (
        response &&
        typeof response === "object" &&
        "tool_calls" in response
      ) {
        const toolCalls = response.tool_calls as Array<{
          name: string;
          arguments: Record<string, unknown>;
        }>;


        // Parse and fix stringified shapes parameters
        return toolCalls.map((call) => {
          const params = call.arguments;

          // Fix: AI sometimes returns shapes as stringified JSON
          if (params.shapes && typeof params.shapes === "string") {
            console.warn("[AIAgent] ⚠ Fixing stringified shapes parameter");
            try {
              params.shapes = JSON.parse(params.shapes);
            } catch {
              // Try normalizing quotes
              try {
                const normalized = (params.shapes as string)
                  .replace(/'/g, '"')
                  .replace(/(\w+):/g, '"$1":');
                params.shapes = JSON.parse(normalized);
              } catch (parseError) {
                console.error("[AIAgent] Failed to parse shapes:", parseError);
              }
            }
          }

          return {
            name: call.name,
            parameters: params,
          };
        });
      }

      // Fallback: try to parse text response
      if (response && typeof response === "object" && "response" in response) {
        const textResponse = (response as { response?: string }).response;

        // Try to extract and fix the response - AI sometimes returns it as a string
        try {
          if (!textResponse) {
            throw new Error("Empty text response from AI");
          }

          // Try to extract JSON from the response
          // The response might be: {"name": "createShape", "arguments": {"shapes": "[...]"}}
          // Or it might be truncated, so we need to handle that
          const jsonMatch = textResponse.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const jsonStr = jsonMatch[0];

            // Check if JSON is truncated (unterminated string/array/object)
            const openBraces = (jsonStr.match(/\{/g) || []).length;
            const closeBraces = (jsonStr.match(/\}/g) || []).length;
            const openBrackets = (jsonStr.match(/\[/g) || []).length;
            const closeBrackets = (jsonStr.match(/\]/g) || []).length;
            const openQuotes = (jsonStr.match(/"/g) || []).length;

            if (
              openBraces !== closeBraces ||
              openBrackets !== closeBrackets ||
              openQuotes % 2 !== 0
            ) {
              console.error("[AIAgent] ✗ Response appears truncated:", {
                openBraces,
                closeBraces,
                openBrackets,
                closeBrackets,
                openQuotes,
              });
              throw new Error(
                "AI response was truncated. Try a simpler prompt.",
              );
            }

            const parsed = JSON.parse(jsonStr);

            // If it looks like a tool call structure
            if (parsed.name && parsed.arguments) {

              // Fix stringified shapes parameter if present
              if (
                parsed.arguments.shapes &&
                typeof parsed.arguments.shapes === "string"
              ) {
                try {
                  parsed.arguments.shapes = JSON.parse(parsed.arguments.shapes);
                } catch {
                  // Try fixing quotes
                  const normalized = (parsed.arguments.shapes as string)
                    .replace(/'/g, '"')
                    .replace(/(\w+):/g, '"$1":');
                  parsed.arguments.shapes = JSON.parse(normalized);
                }
              }

              return [
                {
                  name: parsed.name,
                  parameters: parsed.arguments,
                },
              ];
            }

            // Legacy format check
            if (parsed.shapes && Array.isArray(parsed.shapes)) {
              return [
                {
                  name: "createShape",
                  parameters: { shapes: parsed.shapes },
                },
              ];
            }
          }
        } catch (parseError) {
          console.error(
            "[AIAgent] Failed to parse JSON from text:",
            parseError,
          );
          console.error(
            "[AIAgent] Partial response:",
            textResponse?.substring(0, 200),
          );

          // Provide helpful error message
          if (
            parseError instanceof SyntaxError &&
            parseError.message.includes("Unterminated")
          ) {
            throw new Error(
              "AI response was incomplete (truncated). Please try a simpler command with fewer shapes.",
            );
          }
        }

        throw new Error(
          `AI responded but didn't call any tools. Response: ${textResponse?.substring(0, 100) || "unknown"}`,
        );
      }

      console.warn("[AIAgent] No tool_calls or text response in AI output");
      return [];
    } catch (error) {
      console.error("[AIAgent] AI call failed:", error);

      // Provide user-friendly error messages
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      if (
        errorMessage.includes("truncated") ||
        errorMessage.includes("Unterminated")
      ) {
        throw new Error(
          "AI response was incomplete. Try a simpler command with fewer shapes (max 20 shapes per command recommended).",
        );
      }

      throw new Error(`AI inference failed: ${errorMessage}`);
    }
  }

  /**
   * Validate tool calls before execution
   */
  private validateToolCalls(
    toolCalls: Array<{ name: string; parameters: Record<string, unknown> }>,
  ): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    let totalShapesToCreate = 0;
    const MAX_SHAPES = 50;
    const MIN_RECTANGLE_SIZE = 10;
    const MIN_CIRCLE_RADIUS = 5;

    for (const call of toolCalls) {
      if (call.name === "createShape") {
        const params = call.parameters;

        // Handle array format
        if ("shapes" in params && Array.isArray(params.shapes)) {
          const shapes = params.shapes as Array<Record<string, unknown>>;
          totalShapesToCreate += shapes.length;

          for (const shape of shapes) {
            if (shape.type === "rectangle") {
              const width = shape.width as number;
              const height = shape.height as number;
              if (
                width &&
                height &&
                (width < MIN_RECTANGLE_SIZE || height < MIN_RECTANGLE_SIZE)
              ) {
                errors.push(
                  `Rectangle too small: ${width}x${height}px (min ${MIN_RECTANGLE_SIZE}x${MIN_RECTANGLE_SIZE}px)`,
                );
              }
            } else if (shape.type === "circle") {
              const radius = shape.radius as number;
              if (radius && radius < MIN_CIRCLE_RADIUS) {
                errors.push(
                  `Circle too small: ${radius}px radius (min ${MIN_CIRCLE_RADIUS}px)`,
                );
              }
            }
          }
        }
      }
    }

    if (totalShapesToCreate > MAX_SHAPES) {
      errors.push(
        `Total shapes requested: ${totalShapesToCreate}. Maximum is ${MAX_SHAPES} per command.`,
      );
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Get room ID from request headers
   * The Worker passes the room ID via x-room-id header
   */
  private getRoomId(request: Request): string {
    // Get room ID from header (set by Worker)
    const roomId = request.headers.get("x-room-id");

    if (roomId) {
      return roomId;
    }

    // Fallback to "main" if header not present
    console.warn("[AIAgent] ⚠ No x-room-id header found, using default 'main'");
    return "main";
  }

  /**
   * Authorize request and return role
   */
  private async authorizeRequest(
    request: Request,
  ): Promise<"editor" | "viewer"> {
    // biome-ignore lint/suspicious/noExplicitAny: Agent framework limitation - env property not typed
    const env = this.env as any;
    const clerkSecretKey = env.CLERK_SECRET_KEY;
    if (!clerkSecretKey) {
      console.warn("[AIAgent] No CLERK_SECRET_KEY, treating as viewer");
      return "viewer";
    }

    const token = this.extractToken(request);
    if (!token) {
      return "viewer";
    }

    try {
      const jwtPayload = await verifyToken(token, {
        secretKey: clerkSecretKey,
      });

      if (jwtPayload?.sub) {
        return "editor";
      }

      return "viewer";
    } catch (error) {
      console.warn("[AIAgent] Token verification failed:", error);
      return "viewer";
    }
  }

  /**
   * Extract JWT token from request
   */
  private extractToken(request: Request): string | null {
    const url = new URL(request.url);
    const authHeader = request.headers.get("Authorization");
    const headerToken = authHeader?.startsWith("Bearer ")
      ? authHeader.slice("Bearer ".length)
      : null;
    const queryToken = url.searchParams.get("token");
    return headerToken ?? queryToken;
  }

  /**
   * Get user info from JWT
   * Extracts userId and userName from Clerk JWT payload
   */
  private async getUserInfo(
    request: Request,
  ): Promise<{ userId: string; userName: string }> {
    const token = this.extractToken(request);
    // biome-ignore lint/suspicious/noExplicitAny: Agent framework limitation - env property not typed
    const env = this.env as any;
    const clerkSecretKey = env.CLERK_SECRET_KEY;

    if (token && clerkSecretKey) {
      try {
        const jwtPayload = await verifyToken(token, {
          secretKey: clerkSecretKey,
        });
        if (jwtPayload?.sub) {
          // Clerk JWT may contain: firstName, lastName, email, username
          // Try multiple fields to get a good display name
          const payload = jwtPayload as {
            sub: string;
            username?: string;
            firstName?: string;
            lastName?: string;
            email?: string;
          };

          let userName = "";
          if (payload.firstName || payload.lastName) {
            userName = [payload.firstName, payload.lastName]
              .filter(Boolean)
              .join(" ");
          } else if (payload.username) {
            userName = payload.username;
          } else if (payload.email) {
            // Use part before @ from email
            userName = payload.email.split("@")[0];
          }

          // Fallback to truncated userId if no name found
          if (!userName) {
            userName = `User ${payload.sub.slice(0, 8)}`;
          }

          return {
            userId: payload.sub,
            userName,
          };
        }
      } catch (error) {
        console.warn(
          "[AIAgent] Failed to extract user info from token:",
          error,
        );
        // Continue with anonymous
      }
    }

    return {
      userId: "anonymous",
      userName: "Anonymous",
    };
  }

  /**
   * Get cached command result from Agent state
   */
  private async getCachedCommand(
    commandId: string,
  ): Promise<Record<string, unknown> | null> {
    // Agent framework provides ctx.storage for state management
    const storage = this.ctx?.storage;
    if (!storage) return null;

    const cache = (await storage.get(`command:${commandId}`)) as
      | Record<string, unknown>
      | undefined;
    return cache ?? null;
  }

  /**
   * Cache command result in Agent state
   */
  private async cacheCommandResult(
    commandId: string,
    result: Record<string, unknown>,
  ): Promise<void> {
    // Agent framework provides ctx.storage for state management
    const storage = this.ctx?.storage;
    if (!storage) return;

    await storage.put(`command:${commandId}`, result);
  }
}
